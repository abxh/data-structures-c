<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>data-structures-c: lib/fhashtable.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">data-structures-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fhashtable.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Fixed-size hashtable data structure based on open adressing (robin hood hashing).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="murmurhash_8h_source.html">murmurhash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="paste_8h_source.html">paste.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="round__up__pow2_8h_source.html">round_up_pow2.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div>
<p><a href="fhashtable_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfhashtable__slot__type.html">fhashtable_slot_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated hashtable slot struct type for a given <code>KEY_TYPE</code> and <code>VALUE_TYPE</code>.  <a href="structfhashtable__slot__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfhashtable__type.html">fhashtable_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated hashtable struct type for a given <code>KEY_TYPE</code> and <code>VALUE_TYPE</code>.  <a href="structfhashtable__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a47f2e62c0dbebc787052c165afcada0e" id="r_a47f2e62c0dbebc787052c165afcada0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47f2e62c0dbebc787052c165afcada0e">NAME</a>&#160;&#160;&#160;fhashtable</td></tr>
<tr class="memdesc:a47f2e62c0dbebc787052c165afcada0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix to queue type and operations.  <br /></td></tr>
<tr class="separator:a47f2e62c0dbebc787052c165afcada0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35c40bc2f912c11f0e36ac66cba4489" id="r_ae35c40bc2f912c11f0e36ac66cba4489"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a>&#160;&#160;&#160;int</td></tr>
<tr class="memdesc:ae35c40bc2f912c11f0e36ac66cba4489"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key type. This must be manually defined before including this header file.  <br /></td></tr>
<tr class="separator:ae35c40bc2f912c11f0e36ac66cba4489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17cb099b4c9aee7835032339b5a9e0d" id="r_ae17cb099b4c9aee7835032339b5a9e0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a>&#160;&#160;&#160;int</td></tr>
<tr class="memdesc:ae17cb099b4c9aee7835032339b5a9e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type. This must be manually defined before including this header file.  <br /></td></tr>
<tr class="separator:ae17cb099b4c9aee7835032339b5a9e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a9b9662f87dfedd00cc6fd5dde7852" id="r_a58a9b9662f87dfedd00cc6fd5dde7852"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58a9b9662f87dfedd00cc6fd5dde7852">KEY_IS_EQUAL</a>(a,  b)&#160;&#160;&#160;((a) == (b))</td></tr>
<tr class="memdesc:a58a9b9662f87dfedd00cc6fd5dde7852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to compare two keys. This must be manually defined before including this header file.  <br /></td></tr>
<tr class="separator:a58a9b9662f87dfedd00cc6fd5dde7852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261e2befaaf40b08c99064bb53bf0b44" id="r_a261e2befaaf40b08c99064bb53bf0b44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a261e2befaaf40b08c99064bb53bf0b44">HASH_FUNCTION</a>(key)&#160;&#160;&#160;(<a class="el" href="murmurhash_8h.html#acb0c380e343772042ae656fb60679886">murmur3_32</a>((uint8_t*)&amp;(key), sizeof(<a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a>), 0))</td></tr>
<tr class="memdesc:a261e2befaaf40b08c99064bb53bf0b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to compute indicies of keys. This must be manually defined before including this header file.  <br /></td></tr>
<tr class="separator:a261e2befaaf40b08c99064bb53bf0b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa799886ed218fb21a6ca4787cf83e8d4" id="r_aa799886ed218fb21a6ca4787cf83e8d4"><td class="memItemLeft" align="right" valign="top"><a id="aa799886ed218fb21a6ca4787cf83e8d4" name="aa799886ed218fb21a6ca4787cf83e8d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FHASHTABLE_EMPTY_SLOT_OFFSET</b>&#160;&#160;&#160;(SIZE_MAX)</td></tr>
<tr class="memdesc:aa799886ed218fb21a6ca4787cf83e8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset constant used to flag empty slots. <br /></td></tr>
<tr class="separator:aa799886ed218fb21a6ca4787cf83e8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ab43d6ec197c44dc97808300246ad2" id="r_a73ab43d6ec197c44dc97808300246ad2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73ab43d6ec197c44dc97808300246ad2">FHASHTABLE_FOREACH</a>(hashtable_ptr,  key_,  value_)</td></tr>
<tr class="memdesc:a73ab43d6ec197c44dc97808300246ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the non-empty slots in the hashtable in arbitary order.  <br /></td></tr>
<tr class="separator:a73ab43d6ec197c44dc97808300246ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6140b0b995c58340aca710028fccf7b3" id="r_a6140b0b995c58340aca710028fccf7b3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6140b0b995c58340aca710028fccf7b3">fhashtable_create</a> (const size_t capacity)</td></tr>
<tr class="memdesc:a6140b0b995c58340aca710028fccf7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an hashtable with a given capacity with malloc().  <br /></td></tr>
<tr class="separator:a6140b0b995c58340aca710028fccf7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7aed9cc621ee1c8f14bad250b15a26" id="r_adb7aed9cc621ee1c8f14bad250b15a26"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb7aed9cc621ee1c8f14bad250b15a26">fhashtable_destroy</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr)</td></tr>
<tr class="memdesc:adb7aed9cc621ee1c8f14bad250b15a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an hashtable and free the underlying memory with free().  <br /></td></tr>
<tr class="separator:adb7aed9cc621ee1c8f14bad250b15a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bff642d403fc2ee334cdebffe0bcba" id="r_a06bff642d403fc2ee334cdebffe0bcba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06bff642d403fc2ee334cdebffe0bcba">fhashtable_is_empty</a> (const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr)</td></tr>
<tr class="memdesc:a06bff642d403fc2ee334cdebffe0bcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the hashtable is empty.  <br /></td></tr>
<tr class="separator:a06bff642d403fc2ee334cdebffe0bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08423f9c44b01727612d2e2c3c50bc8" id="r_ac08423f9c44b01727612d2e2c3c50bc8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac08423f9c44b01727612d2e2c3c50bc8">fhashtable_is_full</a> (const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr)</td></tr>
<tr class="memdesc:ac08423f9c44b01727612d2e2c3c50bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the hashtable is full.  <br /></td></tr>
<tr class="separator:ac08423f9c44b01727612d2e2c3c50bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62110c48325451d327323e324a844114" id="r_a62110c48325451d327323e324a844114"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62110c48325451d327323e324a844114">fhashtable_contains_key</a> (const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr, const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a> key)</td></tr>
<tr class="memdesc:a62110c48325451d327323e324a844114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if hashtable contains a key.  <br /></td></tr>
<tr class="separator:a62110c48325451d327323e324a844114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2922923a570f5b7294467e155ddf27" id="r_afb2922923a570f5b7294467e155ddf27"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2922923a570f5b7294467e155ddf27">fhashtable_get_value_mut</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr, const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a> key)</td></tr>
<tr class="memdesc:afb2922923a570f5b7294467e155ddf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a given key, get the pointer to the corresponding value in the hashtable.  <br /></td></tr>
<tr class="separator:afb2922923a570f5b7294467e155ddf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1f9f3f4d3386f2aee8f864e5fb91ca" id="r_add1f9f3f4d3386f2aee8f864e5fb91ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add1f9f3f4d3386f2aee8f864e5fb91ca">fhashtable_get_value</a> (const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr, const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a> key, const <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> default_value)</td></tr>
<tr class="memdesc:add1f9f3f4d3386f2aee8f864e5fb91ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a given key, get the copy of the corresponding value in the hashtable.  <br /></td></tr>
<tr class="separator:add1f9f3f4d3386f2aee8f864e5fb91ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45f2b3725a831db88804e05a55baf15" id="r_ac45f2b3725a831db88804e05a55baf15"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac45f2b3725a831db88804e05a55baf15">fhashtable_search</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr, const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a> key)</td></tr>
<tr class="memdesc:ac45f2b3725a831db88804e05a55baf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a given key in the hashtable and get the pointer to the corresponding value.  <br /></td></tr>
<tr class="separator:ac45f2b3725a831db88804e05a55baf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11d94d20047d74fe92ac185adc92400" id="r_aa11d94d20047d74fe92ac185adc92400"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa11d94d20047d74fe92ac185adc92400">fhashtable_insert</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr, <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a> key, <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> value)</td></tr>
<tr class="memdesc:aa11d94d20047d74fe92ac185adc92400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a non-duplicate key and it's corresponding value inside the hashtable.  <br /></td></tr>
<tr class="separator:aa11d94d20047d74fe92ac185adc92400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9175c3e992a4e42e9b56e62245e8c8" id="r_a5c9175c3e992a4e42e9b56e62245e8c8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c9175c3e992a4e42e9b56e62245e8c8">fhashtable_update</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr, <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a> key, <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> value)</td></tr>
<tr class="memdesc:a5c9175c3e992a4e42e9b56e62245e8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a key's corresponding value inside the hashtable. Allows duplicates.  <br /></td></tr>
<tr class="separator:a5c9175c3e992a4e42e9b56e62245e8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c29d601849ae3126a2ae4847c8131d0" id="r_a0c29d601849ae3126a2ae4847c8131d0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c29d601849ae3126a2ae4847c8131d0">fhashtable_delete</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr, const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a> key)</td></tr>
<tr class="memdesc:a0c29d601849ae3126a2ae4847c8131d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a key and it's corresponding value from the hashtable.  <br /></td></tr>
<tr class="separator:a0c29d601849ae3126a2ae4847c8131d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb4c4445b4a40dbfdff14570f1a62f4" id="r_adeb4c4445b4a40dbfdff14570f1a62f4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeb4c4445b4a40dbfdff14570f1a62f4">fhashtable_clear</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *hashtable_ptr)</td></tr>
<tr class="memdesc:adeb4c4445b4a40dbfdff14570f1a62f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an existing hashtable and flag all slots as empty.  <br /></td></tr>
<tr class="separator:adeb4c4445b4a40dbfdff14570f1a62f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b25dc161b7f4310985a9f3d5174e908" id="r_a4b25dc161b7f4310985a9f3d5174e908"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b25dc161b7f4310985a9f3d5174e908">fhashtable_copy</a> (<a class="el" href="structfhashtable__type.html">fhashtable_type</a> *restrict dest_stack_ptr, const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *restrict src_stack_ptr)</td></tr>
<tr class="memdesc:a4b25dc161b7f4310985a9f3d5174e908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values from a source hashtable to a destination hashtable.  <br /></td></tr>
<tr class="separator:a4b25dc161b7f4310985a9f3d5174e908"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Fixed-size hashtable data structure based on open adressing (robin hood hashing). </p>
<p>Ensure the capacity rounded up to the power of 2 is 75% of the expected numbers of values to be stored to keep load factor low and the hash table performant. Also note, searching for missing keys in full hashtables makes the search procedures loop indefinitely - so ensure the hashtable doesn't get full.</p>
<p>Prefer to use scalar types (int/uint/pointers) or strings as key/value pairs. Structs can be used with elementwise equality check but will not make use the cache and hardware prefetching as well. Keep the structs in a seperate buffer and use their pointers preferably.</p>
<p>A static / heap-allocated buffer should be used, should the key/values's lifetime extend beyond the scope the arguments are provided. This applies to strings. See example.</p>
<p>The following macros must be defined: </p><ul>
<li><code>NAME</code> </li>
<li><code>KEY_TYPE</code> </li>
<li><code>VALUE_TYPE</code> </li>
<li><code><a class="el" href="#a58a9b9662f87dfedd00cc6fd5dde7852" title="Used to compare two keys. This must be manually defined before including this header file.">KEY_IS_EQUAL(a,b)</a></code> </li>
<li><code><a class="el" href="#a261e2befaaf40b08c99064bb53bf0b44" title="Used to compute indicies of keys. This must be manually defined before including this header file.">HASH_FUNCTION(key)</a></code></li>
</ul>
<p>Source(s) used for inspiration: </p><ul>
<li><a href="https://thenumb.at/Hashtables/#robin-hood-linear-probing">https://thenumb.at/Hashtables/#robin-hood-linear-probing</a> </li>
<li><a href="https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/">https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/</a> </li>
<li><a href="https://github.com/rmind/rhashmap/blob/master/src/rhashmap.c">https://github.com/rmind/rhashmap/blob/master/src/rhashmap.c</a> </li>
<li><a href="https://github.com/tezc/sc/tree/master/map">https://github.com/tezc/sc/tree/master/map</a> </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a73ab43d6ec197c44dc97808300246ad2" name="a73ab43d6ec197c44dc97808300246ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ab43d6ec197c44dc97808300246ad2">&#9670;&#160;</a></span>FHASHTABLE_FOREACH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FHASHTABLE_FOREACH</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>key_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>value_</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> _index = 0; _index &lt; (hashtable_ptr)-&gt;capacity; _index++)            \</div>
<div class="line">                                                                                     \</div>
<div class="line">        <span class="keywordflow">if</span> ((hashtable_ptr)-&gt;slots[_index].offset != <a class="code hl_define" href="#aa799886ed218fb21a6ca4787cf83e8d4">FHASHTABLE_EMPTY_SLOT_OFFSET</a> &amp;&amp; \</div>
<div class="line">                                                                                     \</div>
<div class="line">            ((key_) = (hashtable_ptr)-&gt;slots[_index].key, (value_) = (hashtable_ptr)-&gt;slots[_index].value, <span class="keyword">true</span>))</div>
<div class="ttc" id="afhashtable_8h_html_aa799886ed218fb21a6ca4787cf83e8d4"><div class="ttname"><a href="#aa799886ed218fb21a6ca4787cf83e8d4">FHASHTABLE_EMPTY_SLOT_OFFSET</a></div><div class="ttdeci">#define FHASHTABLE_EMPTY_SLOT_OFFSET</div><div class="ttdoc">Offset constant used to flag empty slots.</div><div class="ttdef"><b>Definition</b> fhashtable.h:125</div></div>
</div><!-- fragment -->
<p>Iterate over the non-empty slots in the hashtable in arbitary order. </p>
<dl class="section warning"><dt>Warning</dt><dd>Modifying the hashtable under the iteration may result in errors.</dd></dl>
<p>temporary variables visible in scope: </p><ul>
<li>_index</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>hashtable pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_</td><td>Current key. Should be <code>KEY_TYPE</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value_</td><td>Current value. Should be <code>VALUE_TYPE</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="fhashtable_2fhashtable_8c-example.html#a0">fhashtable/fhashtable.c</a>.</dd>
</dl>

</div>
</div>
<a id="a261e2befaaf40b08c99064bb53bf0b44" name="a261e2befaaf40b08c99064bb53bf0b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261e2befaaf40b08c99064bb53bf0b44">&#9670;&#160;</a></span>HASH_FUNCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HASH_FUNCTION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="murmurhash_8h.html#acb0c380e343772042ae656fb60679886">murmur3_32</a>((uint8_t*)&amp;(key), sizeof(<a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a>), 0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to compute indicies of keys. This must be manually defined before including this header file. </p>
<p>Is undefined once header is included.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>hash of the key as <code>size_t</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58a9b9662f87dfedd00cc6fd5dde7852" name="a58a9b9662f87dfedd00cc6fd5dde7852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a9b9662f87dfedd00cc6fd5dde7852">&#9670;&#160;</a></span>KEY_IS_EQUAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KEY_IS_EQUAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)&#160;&#160;&#160;((a) == (b))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to compare two keys. This must be manually defined before including this header file. </p>
<p>Is undefined once header is included.</p>
<dl class="section attention"><dt>Attention</dt><dd><ul>
<li>If comparing two scalar values, set this macro to ((a) == (b)). </li>
<li>If comparing two strings, set this macro to strcmp() or strncmp() appropiately. </li>
<li>If comparing two structs, set this macro to a function that does element-wise comparison between the structs. </li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the two keys are equal. Equivalent to a non-zero int. </td></tr>
    <tr><td class="paramname">false</td><td>If the two key are not equal. Equivalent to the int 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae35c40bc2f912c11f0e36ac66cba4489" name="ae35c40bc2f912c11f0e36ac66cba4489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35c40bc2f912c11f0e36ac66cba4489">&#9670;&#160;</a></span>KEY_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KEY_TYPE&#160;&#160;&#160;int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The key type. This must be manually defined before including this header file. </p>
<p>Is undefined once header is included. </p>

</div>
</div>
<a id="a47f2e62c0dbebc787052c165afcada0e" name="a47f2e62c0dbebc787052c165afcada0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f2e62c0dbebc787052c165afcada0e">&#9670;&#160;</a></span>NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NAME&#160;&#160;&#160;fhashtable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix to queue type and operations. </p>
<p>Is undefined after header is included.</p>
<dl class="section attention"><dt>Attention</dt><dd>This must be manually defined before including this header file. </dd></dl>

</div>
</div>
<a id="ae17cb099b4c9aee7835032339b5a9e0d" name="ae17cb099b4c9aee7835032339b5a9e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17cb099b4c9aee7835032339b5a9e0d">&#9670;&#160;</a></span>VALUE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VALUE_TYPE&#160;&#160;&#160;int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value type. This must be manually defined before including this header file. </p>
<p>Is undefined once header is included. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adeb4c4445b4a40dbfdff14570f1a62f4" name="adeb4c4445b4a40dbfdff14570f1a62f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb4c4445b4a40dbfdff14570f1a62f4">&#9670;&#160;</a></span>fhashtable_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fhashtable_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear an existing hashtable and flag all slots as empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The pointer of the hashtable to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62110c48325451d327323e324a844114" name="a62110c48325451d327323e324a844114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62110c48325451d327323e324a844114">&#9670;&#160;</a></span>fhashtable_contains_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fhashtable_contains_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if hashtable contains a key. </p>
<p>Assumes: </p><ul>
<li>hashtable_ptr is not <code>NULL</code>. </li>
<li>there exists at least one empty slot - aka the hashtable is not full.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the hashtable contains the given key. </dd></dl>

</div>
</div>
<a id="a4b25dc161b7f4310985a9f3d5174e908" name="a4b25dc161b7f4310985a9f3d5174e908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b25dc161b7f4310985a9f3d5174e908">&#9670;&#160;</a></span>fhashtable_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fhashtable_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *restrict</td>          <td class="paramname"><span class="paramname"><em>dest_stack_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *restrict</td>          <td class="paramname"><span class="paramname"><em>src_stack_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the values from a source hashtable to a destination hashtable. </p>
<p>Assumes: </p><ul>
<li>Source and destination hashtable pointers are not pointing to the same memory. </li>
<li>The hashtable pointers are not <code>NULL</code>. </li>
<li>The destination hashtable has a capacity that is greater than or equal to source hashtable count. </li>
<li>The destination hashtable is an empty hashtable.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest_hashtable_ptr</td><td>The destination hashtable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_hashtable_ptr</td><td>The source hashtable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6140b0b995c58340aca710028fccf7b3" name="a6140b0b995c58340aca710028fccf7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6140b0b995c58340aca710028fccf7b3">&#9670;&#160;</a></span>fhashtable_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structfhashtable__type.html">fhashtable_type</a> * fhashtable_create </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an hashtable with a given capacity with malloc(). </p>
<dl class="section note"><dt>Note</dt><dd>Ensure the capacity rounded up to the power of 2 is 75% of the expected numbers of values to be stored to keep load factor low and the hash table performant.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Maximum number of elements expected to be stored in the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the queue. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">`NULL`</td><td><ul>
<li>If malloc fails. </li>
<li>If capacity is less than 2 or the hashtable size [rounded up to the power of 2] is larger than UINT32_MAX / 4. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c29d601849ae3126a2ae4847c8131d0" name="a0c29d601849ae3126a2ae4847c8131d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c29d601849ae3126a2ae4847c8131d0">&#9670;&#160;</a></span>fhashtable_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fhashtable_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a key and it's corresponding value from the hashtable. </p>
<p>Assumes hashtable_ptr is not <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the key was previously contained in the hashtable. </dd></dl>

</div>
</div>
<a id="adb7aed9cc621ee1c8f14bad250b15a26" name="adb7aed9cc621ee1c8f14bad250b15a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7aed9cc621ee1c8f14bad250b15a26">&#9670;&#160;</a></span>fhashtable_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fhashtable_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy an hashtable and free the underlying memory with free(). </p>
<p>Assumes: </p><ul>
<li>The hashtable pointer is not <code>NULL</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>May not be called twice in a row on the same object. </dd></dl>

</div>
</div>
<a id="add1f9f3f4d3386f2aee8f864e5fb91ca" name="add1f9f3f4d3386f2aee8f864e5fb91ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1f9f3f4d3386f2aee8f864e5fb91ca">&#9670;&#160;</a></span>fhashtable_get_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> fhashtable_get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>From a given key, get the copy of the corresponding value in the hashtable. </p>
<p>Assumes: </p><ul>
<li>hashtable_ptr is not <code>NULL</code>. </li>
<li>there exists at least one empty slot - aka the hashtable is not full.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>The default value returned if the hashtable did not contain the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding key. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">default_value</td><td>If the hashtable did not contain the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb2922923a570f5b7294467e155ddf27" name="afb2922923a570f5b7294467e155ddf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2922923a570f5b7294467e155ddf27">&#9670;&#160;</a></span>fhashtable_get_value_mut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> * fhashtable_get_value_mut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>From a given key, get the pointer to the corresponding value in the hashtable. </p>
<p>Assumes: </p><ul>
<li>hashtable_ptr is not <code>NULL</code>. </li>
<li>there exists at least one empty slot - aka the hashtable is not full.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The returned pointer is <b>not</b> garanteed to point to the same value if the hashtable is modified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding key. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>If the hashtable did not contain the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa11d94d20047d74fe92ac185adc92400" name="aa11d94d20047d74fe92ac185adc92400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11d94d20047d74fe92ac185adc92400">&#9670;&#160;</a></span>fhashtable_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fhashtable_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a non-duplicate key and it's corresponding value inside the hashtable. </p>
<p>Assumes: </p><ul>
<li>hashtable_ptr is not <code>NULL</code>. </li>
<li>key is not already contained in the hashtable. </li>
<li>hash table is not full.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06bff642d403fc2ee334cdebffe0bcba" name="a06bff642d403fc2ee334cdebffe0bcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bff642d403fc2ee334cdebffe0bcba">&#9670;&#160;</a></span>fhashtable_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fhashtable_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the hashtable is empty. </p>
<p>Assumes the hashtable pointer is not <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the hashtable is empty. </dd></dl>

</div>
</div>
<a id="ac08423f9c44b01727612d2e2c3c50bc8" name="ac08423f9c44b01727612d2e2c3c50bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08423f9c44b01727612d2e2c3c50bc8">&#9670;&#160;</a></span>fhashtable_is_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fhashtable_is_full </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the hashtable is full. </p>
<p>Assumes the hashtable pointer is not <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the hashtable is full. </dd></dl>

</div>
</div>
<a id="ac45f2b3725a831db88804e05a55baf15" name="ac45f2b3725a831db88804e05a55baf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45f2b3725a831db88804e05a55baf15">&#9670;&#160;</a></span>fhashtable_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a> * fhashtable_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a given key in the hashtable and get the pointer to the corresponding value. </p>
<p>Assumes hashtable_ptr is not <code>NULL</code>.</p>
<p>The returned pointer is <b>not</b> garanteed to point to the same value if the hashtable is modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding key. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>If the hashtable did not contain the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c9175c3e992a4e42e9b56e62245e8c8" name="a5c9175c3e992a4e42e9b56e62245e8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9175c3e992a4e42e9b56e62245e8c8">&#9670;&#160;</a></span>fhashtable_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fhashtable_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfhashtable__type.html">fhashtable_type</a> *</td>          <td class="paramname"><span class="paramname"><em>hashtable_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae17cb099b4c9aee7835032339b5a9e0d">VALUE_TYPE</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a key's corresponding value inside the hashtable. Allows duplicates. </p>
<p>If a duplicate key is found, the corresponding value is overwritten.</p>
<p>Assumes: </p><ul>
<li>hashtable_ptr is not <code>NULL</code>. </li>
<li>hash table is not full.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtable_ptr</td><td>The hashtable pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
